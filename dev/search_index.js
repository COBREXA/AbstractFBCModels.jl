var documenterSearchIndex = {"docs":
[{"location":"canonical/","page":"Custom models","title":"Custom models","text":"EditURL = \"canonical.jl\"","category":"page"},{"location":"canonical/#Custom-models","page":"Custom models","title":"Custom models","text":"","category":"section"},{"location":"canonical/","page":"Custom models","title":"Custom models","text":"For convenience, AbstractFBCModels defines a \"canonical\" implementation of a FBC model: a completely generic data structure that can store exactly the complete information that is representable by the AbstractFBCModel accessors, and nothing else.","category":"page"},{"location":"canonical/","page":"Custom models","title":"Custom models","text":"The type is not useful for actually constructing the models, but may serve a good purpose in several other cases:","category":"page"},{"location":"canonical/","page":"Custom models","title":"Custom models","text":"If you need an \"intermediate step\" when converting complicated FBC models to other types, the canonical model is guaranteed not to lose any information, yet perform relatively well when re-exporting the information via the accessors.\nIf you need to make quick modifications to another model type that does not admin easy mutation (e.g., it is made of immutable structs), you can convert to the canonical model and make the small fixes in there.\nHere, we use it for describing how to \"perform\" your own definition of model type, and demonstrate the use of the pre-defined testing framework on it.","category":"page"},{"location":"canonical/","page":"Custom models","title":"Custom models","text":"The model is available for use as AbstractFBCModels.CanonicalModel.Model","category":"page"},{"location":"canonical/#Defining-the-model","page":"Custom models","title":"Defining the model","text":"","category":"section"},{"location":"canonical/","page":"Custom models","title":"Custom models","text":"For convenience in the later explanation, we list the whole definition of the module here:","category":"page"},{"location":"canonical/","page":"Custom models","title":"Custom models","text":"\nmodule CanonicalModel\n\nusing DocStringExtensions\n\nimport ..AbstractFBCModels as A\nimport Serialization as S\nimport SparseArrays: sparse, findnz\n\n\"\"\"\n$(TYPEDEF)\n\nA canonical Julia representation of a reaction in the `AbstractFBCModels` interface.\n\n# Fields\n$(TYPEDFIELDS)\n\"\"\"\nBase.@kwdef mutable struct Reaction\n    name::A.Maybe{String} = nothing\n    lower_bound::Float64 = -Inf\n    upper_bound::Float64 = Inf\n    stoichiometry::Dict{String,Float64} = Dict()\n    objective_coefficient::Float64 = 0.0\n    gene_association_dnf::A.Maybe{A.GeneAssociationDNF} = nothing\n    annotations::A.Annotations = A.Annotations()\n    notes::A.Notes = A.Notes()\nend\n\n\"\"\"\n$(TYPEDEF)\n\nA canonical Julia representation of a metabolite in the `AbstractFBCModels` interface.\n\n# Fields\n$(TYPEDFIELDS)\n\"\"\"\nBase.@kwdef mutable struct Metabolite\n    name::A.Maybe{String} = nothing\n    compartment::A.Maybe{String} = nothing\n    formula::A.Maybe{A.MetaboliteFormula} = nothing\n    charge::A.Maybe{Int} = nothing\n    balance::Float64 = 0.0\n    annotations::A.Annotations = A.Annotations()\n    notes::A.Notes = A.Notes()\nend\n\n\"\"\"\n$(TYPEDEF)\n\nA canonical Julia representation of a gene in the `AbstractFBCModels` interface.\n\n# Fields\n$(TYPEDFIELDS)\n\"\"\"\nBase.@kwdef mutable struct Gene\n    name::A.Maybe{String} = nothing\n    annotations::A.Annotations = A.Annotations()\n    notes::A.Notes = A.Notes()\nend\n\n\"\"\"\n$(TYPEDEF)\n\nA canonical Julia representation of a metabolic model that sotres exactly the\ndata represented by `AbstractFBCModels` accessors.\n\nThe implementation is useful for manipulating model data manually without\nwriting new model types, or even for constructing models from base data in many\nsimple cases.\n\nAdditionally, you can use the implementation of accessors for this model type\nin the source code of `AbstractFBCModels` as a starting point for creating an\n`AbstractFBCModel` interface for your own models.\n\n# Fields\n$(TYPEDFIELDS)\n\"\"\"\nBase.@kwdef struct Model <: A.AbstractFBCModel\n    reactions::Dict{String,Reaction} = Dict()\n    metabolites::Dict{String,Metabolite} = Dict()\n    genes::Dict{String,Gene} = Dict()\nend\n\nA.reactions(m::Model) = sort(collect(keys(m.reactions)))\nA.metabolites(m::Model) = sort(collect(keys(m.metabolites)))\nA.genes(m::Model) = sort(collect(keys(m.genes)))\nA.n_reactions(m::Model) = length(m.reactions)\nA.n_metabolites(m::Model) = length(m.metabolites)\nA.n_genes(m::Model) = length(m.genes)\nA.reaction_name(m::Model, id::String) = m.reactions[id].name\nA.metabolite_name(m::Model, id::String) = m.metabolites[id].name\nA.gene_name(m::Model, id::String) = m.genes[id].name\nA.reaction_annotations(m::Model, id::String) = m.reactions[id].annotations\nA.metabolite_annotations(m::Model, id::String) = m.metabolites[id].annotations\nA.gene_annotations(m::Model, id::String) = m.genes[id].annotations\nA.reaction_notes(m::Model, id::String) = m.reactions[id].notes\nA.metabolite_notes(m::Model, id::String) = m.metabolites[id].notes\nA.gene_notes(m::Model, id::String) = m.genes[id].notes\n\nA.stoichiometry(m::Model) =\n    let rids = A.reactions(m)\n        #TODO this is dense\n        sparse(\n            Float64[\n                get(m.reactions[rid].stoichiometry, mid, 0.0) for mid in A.metabolites(m),\n                rid in rids\n            ],\n        )\n    end\n\nA.bounds(m::Model) = (\n    [m.reactions[rid].lower_bound for rid in A.reactions(m)],\n    [m.reactions[rid].upper_bound for rid in A.reactions(m)],\n)\n\nA.balance(m::Model) =\n    sparse(Float64[m.metabolites[mid].balance for mid in A.metabolites(m)])\nA.objective(m::Model) =\n    sparse(Float64[m.reactions[rid].objective_coefficient for rid in A.reactions(m)])\n\nA.reaction_gene_association_dnf(m::Model, id::String) = m.reactions[id].gene_association_dnf\nA.reaction_gene_products_available(m::Model, id::String, fn::Function) =\n    A.reaction_gene_products_available_from_dnf(m, id, fn)\nA.reaction_stoichiometry(m::Model, id::String) = m.reactions[id].stoichiometry\n\nA.metabolite_formula(m::Model, id::String) = m.metabolites[id].formula\nA.metabolite_charge(m::Model, id::String) = m.metabolites[id].charge\nA.metabolite_compartment(m::Model, id::String) = m.metabolites[id].compartment\n\nA.load(::Type{Model}, path::String)::Model = S.deserialize(path)\nA.save(m::Model, path::String) = S.serialize(path, m)\nA.filename_extensions(::Type{Model}) = [\"canonical-serialized-fbc\"]\n\nfunction Base.convert(::Type{Model}, x::A.AbstractFBCModel)\n    (lbs, ubs) = A.bounds(x)\n    os = A.objective(x)\n    bs = A.balance(x)\n    mets = A.metabolites(x)\n    Model(\n        reactions = Dict(\n            r => Reaction(\n                name = A.reaction_name(x, r),\n                lower_bound = lb,\n                upper_bound = ub,\n                stoichiometry = A.reaction_stoichiometry(x, r),\n                gene_association_dnf = A.reaction_gene_association_dnf(x, r),\n                annotations = A.reaction_annotations(x, r),\n                notes = A.reaction_notes(x, r),\n            ) for (r, lb, ub) in zip(A.reactions(x), lbs, ubs)\n        ),\n        metabolites = Dict(\n            m => Metabolite(\n                name = A.metabolite_name(x, m),\n                balance = b,\n                formula = A.metabolite_formula(x, m),\n                charge = A.metabolite_charge(x, m),\n                compartment = A.metabolite_compartment(x, m),\n                annotations = A.metabolite_annotations(x, m),\n                notes = A.metabolite_notes(x, m),\n            ) for (m, b) in zip(mets, bs)\n        ),\n        genes = Dict(\n            g => Gene(\n                name = A.gene_name(x, g),\n                annotations = A.gene_annotations(x, g),\n                notes = A.gene_notes(x, g),\n            ) for g in A.genes(x)\n        ),\n    )\nend\n\nend # module CanonicalModel","category":"page"},{"location":"canonical/","page":"Custom models","title":"Custom models","text":"The definition contains several main parts:","category":"page"},{"location":"canonical/","page":"Custom models","title":"Custom models","text":"the data structures for the model and all the main parts\noverloaded accessors that provide generic access for the things in the model\noverloaded loading and saving functions, together with the declaration of the common model suffixes\na conversion function that can extract data using accessors from any other AbstractFBCModel and construct the canonical model.","category":"page"},{"location":"canonical/","page":"Custom models","title":"Custom models","text":"Notably, the default file extension is chosen as very unwieldy so that no one ever really exchanges data using this model type.","category":"page"},{"location":"canonical/#Testing-your-model-definition","page":"Custom models","title":"Testing your model definition","text":"","category":"section"},{"location":"canonical/","page":"Custom models","title":"Custom models","text":"Apart from making sure that the accessors work by usual unit tests, you can use 2 testing functions that scrutinize the expected properties of the model type both solely as a type, and using an example model file. These allow you to discover potential problems, as well as build a self-updating test suite for your model that provides long-term sustainability and quality assurance.","category":"page"},{"location":"canonical/#Running-type-level-tests","page":"Custom models","title":"Running type-level tests","text":"","category":"section"},{"location":"canonical/","page":"Custom models","title":"Custom models","text":"Typically, the test suite would run the following to check if types of everything match the expectations.","category":"page"},{"location":"canonical/","page":"Custom models","title":"Custom models","text":"import AbstractFBCModels as A\nimport AbstractFBCModels.CanonicalModel: Model\n\nA.run_fbcmodel_type_tests(Model);\nnothing #hide","category":"page"},{"location":"canonical/#Making-a-simple-model-for-value-tests","page":"Custom models","title":"Making a simple model for value tests","text":"","category":"section"},{"location":"canonical/","page":"Custom models","title":"Custom models","text":"For testing the values, you need to provide an existing file that contains the model. Let's create some contents first:","category":"page"},{"location":"canonical/","page":"Custom models","title":"Custom models","text":"import AbstractFBCModels.CanonicalModel: Reaction, Metabolite\n\nm = Model()\nm.reactions[\"forward\"] =\n    Reaction(name = \"import\", stoichiometry = Dict(\"m1\" => -1.0, \"m2\" => 1.0))\nm.reactions[\"and_back\"] =\n    Reaction(name = \"export\", stoichiometry = Dict(\"m2\" => -1.0, \"m1\" => 1.0))\nm.metabolites[\"m1\"] = Metabolite(compartment = \"inside\")\nm.metabolites[\"m2\"] = Metabolite(compartment = \"outside\")\nnothing #hide","category":"page"},{"location":"canonical/","page":"Custom models","title":"Custom models","text":"We should immediately find the basic accessors working:","category":"page"},{"location":"canonical/","page":"Custom models","title":"Custom models","text":"A.stoichiometry(m)","category":"page"},{"location":"canonical/","page":"Custom models","title":"Custom models","text":"We can now write the model to disk and try to load it with the default loading function:","category":"page"},{"location":"canonical/","page":"Custom models","title":"Custom models","text":"mktempdir() do dir\n    path = joinpath(dir, \"model.canonical-serialized-fbc\")\n    A.save(m, path)\n    A.load(path)\nend","category":"page"},{"location":"canonical/#Running-the-value-tests","page":"Custom models","title":"Running the value tests","text":"","category":"section"},{"location":"canonical/","page":"Custom models","title":"Custom models","text":"Given the data, value tests have an opportunity to scrutinize much greater amount of properties of the model implementation.","category":"page"},{"location":"canonical/","page":"Custom models","title":"Custom models","text":"Running the tests requires a model type and an \"example\" model file:","category":"page"},{"location":"canonical/","page":"Custom models","title":"Custom models","text":"mktempdir() do dir\n    path = joinpath(dir, \"model.canonical-serialized-fbc\")\n    A.save(m, path)\n    A.run_fbcmodel_file_tests(Model, path, name = \"small model\")\nend;\nnothing #hide","category":"page"},{"location":"canonical/","page":"Custom models","title":"Custom models","text":"","category":"page"},{"location":"canonical/","page":"Custom models","title":"Custom models","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Types","page":"Reference","title":"Types","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [AbstractFBCModels]\nPages = [\"src/types.jl\"]","category":"page"},{"location":"reference/#AbstractFBCModels.Maybe","page":"Reference","title":"AbstractFBCModels.Maybe","text":"A nice name for a \"nullable\" type.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AbstractFBCModels.AbstractFBCModel","page":"Reference","title":"AbstractFBCModels.AbstractFBCModel","text":"abstract type AbstractFBCModel\n\nA supertype of all Flux-balance-Based Constrained metabolic models that share the common interface defined by AbstractFBCModels.jl.\n\nTo use the interface for your type, make it a subtype of AbstractFBCModel and provide methods for various functions used with the model. Use accessors to find the current list of methods, and utilize run_fbcmodel_type_tests and run_fbcmodel_file_tests to test the completeness and compatibility of your implementation with the assumptions of the interface.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AbstractFBCModels.Annotations","page":"Reference","title":"AbstractFBCModels.Annotations","text":"Annotations = Dict{String,Vector{String}}\n\nDictionary used to store (possible multiple) standardized annotations of something, such as a metabolite or a reaction (as listed by metabolites and reactions).\n\nExample\n\nAnnotations(\"PubChem\" => [\"CID12345\", \"CID54321\"])\n\n\n\n\n\n","category":"type"},{"location":"reference/#AbstractFBCModels.GeneAssociationDNF","page":"Reference","title":"AbstractFBCModels.GeneAssociationDNF","text":"GeneAssociationDNF = Vector{Vector{String}}\n\nDisjunctive normal form of simple gene associations. For example, [[A, B], [B]] represents two possibilities to run a given reaction, where the first requires both gene products A and B, while the second possibility only requires gene product C.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AbstractFBCModels.MetaboliteFormula","page":"Reference","title":"AbstractFBCModels.MetaboliteFormula","text":"MetaboliteFormula = Dict{String,Int}\n\nDictionary of atoms and their abundances in a molecule.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AbstractFBCModels.Notes","page":"Reference","title":"AbstractFBCModels.Notes","text":"Notes = Dict{String,Vector{String}}\n\nFree-form notes about something (e.g. a gene listed by genes), categorized by \"topic\".\n\n\n\n\n\n","category":"type"},{"location":"reference/#AbstractFBCModels.SparseMat","page":"Reference","title":"AbstractFBCModels.SparseMat","text":"A shortname for a sparse matrix.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AbstractFBCModels.SparseVec","page":"Reference","title":"AbstractFBCModels.SparseVec","text":"A shortname for a sparse vector.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Model-content-accessors","page":"Reference","title":"Model content accessors","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [AbstractFBCModels]\nPages = [\"src/accessors.jl\"]","category":"page"},{"location":"reference/#AbstractFBCModels.balance-Tuple{AbstractFBCModels.AbstractFBCModel}","page":"Reference","title":"AbstractFBCModels.balance","text":"balance(\n    a::AbstractFBCModels.AbstractFBCModel\n) -> SparseArrays.SparseVector{Float64, Int64}\n\n\nGet the sparse balance vector of a model, which usually corresponds to the accumulation term associated with stoichiometric matrix.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.bounds-Tuple{AbstractFBCModels.AbstractFBCModel}","page":"Reference","title":"AbstractFBCModels.bounds","text":"bounds(\n    a::AbstractFBCModels.AbstractFBCModel\n) -> Tuple{Vector{Float64}, Vector{Float64}}\n\n\nGet the lower and upper bounds of all reactions in a model.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.gene_annotations-Tuple{AbstractFBCModels.AbstractFBCModel, String}","page":"Reference","title":"AbstractFBCModels.gene_annotations","text":"gene_annotations(\n    _::AbstractFBCModels.AbstractFBCModel,\n    gene_id::String\n) -> Dict{String, Vector{String}}\n\n\nA dictionary of standardized names that identify the corresponding gene or product. The dictionary assigns vectors of possible identifiers to identifier system names, such as \"PDB\" => [\"PROT01\"].\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.gene_name-Tuple{AbstractFBCModels.AbstractFBCModel, String}","page":"Reference","title":"AbstractFBCModels.gene_name","text":"gene_name(\n    _::AbstractFBCModels.AbstractFBCModel,\n    gene_id::String\n) -> Union{Nothing, String}\n\n\nThe name of the given gene in the model, if recorded.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.gene_notes-Tuple{AbstractFBCModels.AbstractFBCModel, String}","page":"Reference","title":"AbstractFBCModels.gene_notes","text":"gene_notes(\n    _::AbstractFBCModels.AbstractFBCModel,\n    gene_id::String\n) -> Dict{String, Vector{String}}\n\n\nFree-text notes organized in a dictionary by topics about the given gene in the model.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.genes-Tuple{AbstractFBCModels.AbstractFBCModel}","page":"Reference","title":"AbstractFBCModels.genes","text":"genes(\n    _::AbstractFBCModels.AbstractFBCModel\n) -> Vector{String}\n\n\nReturn identifiers of all genes contained in the model. Empty if none.\n\nGenes are also sometimes called \"gene products\" but we write genes for simplicity.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.metabolite_annotations-Tuple{AbstractFBCModels.AbstractFBCModel, String}","page":"Reference","title":"AbstractFBCModels.metabolite_annotations","text":"metabolite_annotations(\n    _::AbstractFBCModels.AbstractFBCModel,\n    metabolite_id::String\n) -> Dict{String, Vector{String}}\n\n\nA dictionary of standardized names that may help to identify the metabolite. The dictionary should assigns vectors of possible identifiers to identifier system names, such as \"ChEMBL\" => [\"123\"] or \"PubChem\" => [\"CID123\", \"CID654645645\"].\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.metabolite_charge-Tuple{AbstractFBCModels.AbstractFBCModel, String}","page":"Reference","title":"AbstractFBCModels.metabolite_charge","text":"metabolite_charge(\n    _::AbstractFBCModels.AbstractFBCModel,\n    metabolite_id::String\n) -> Union{Nothing, Int64}\n\n\nThe charge of the given metabolite in the model, or nothing in case the charge is not recorded.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.metabolite_compartment-Tuple{AbstractFBCModels.AbstractFBCModel, String}","page":"Reference","title":"AbstractFBCModels.metabolite_compartment","text":"metabolite_compartment(\n    _::AbstractFBCModels.AbstractFBCModel,\n    metabolite_id::String\n) -> Union{Nothing, String}\n\n\nThe compartment of the given metabolite in the model. nothing if no compartment is assigned.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.metabolite_formula-Tuple{AbstractFBCModels.AbstractFBCModel, String}","page":"Reference","title":"AbstractFBCModels.metabolite_formula","text":"metabolite_formula(\n    _::AbstractFBCModels.AbstractFBCModel,\n    metabolite_id::String\n) -> Union{Nothing, Dict{String, Int64}}\n\n\nThe formula of the given metabolite in the model, or nothing in case the formula is not recorded.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.metabolite_name-Tuple{AbstractFBCModels.AbstractFBCModel, String}","page":"Reference","title":"AbstractFBCModels.metabolite_name","text":"metabolite_name(\n    _::AbstractFBCModels.AbstractFBCModel,\n    metabolite_id::String\n) -> Union{Nothing, String}\n\n\nThe name of the given metabolite, if assigned.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.metabolite_notes-Tuple{AbstractFBCModels.AbstractFBCModel, String}","page":"Reference","title":"AbstractFBCModels.metabolite_notes","text":"metabolite_notes(\n    _::AbstractFBCModels.AbstractFBCModel,\n    metabolite_id::String\n) -> Dict{String, Vector{String}}\n\n\nFree-text notes organized in a dictionary by topics about the given metabolite in the model.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.metabolites-Tuple{AbstractFBCModels.AbstractFBCModel}","page":"Reference","title":"AbstractFBCModels.metabolites","text":"metabolites(\n    a::AbstractFBCModels.AbstractFBCModel\n) -> Vector{String}\n\n\nReturn a vector of metabolite identifiers in a model.\n\nAs with reactions, some metabolites in models may be virtual, representing purely technical equality constraints.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.n_genes-Tuple{AbstractFBCModels.AbstractFBCModel}","page":"Reference","title":"AbstractFBCModels.n_genes","text":"n_genes(_::AbstractFBCModels.AbstractFBCModel) -> Int64\n\n\nThe number of genes in the model (must be equal to the length of vector given by genes).\n\nThis may be more efficient than calling genes and measuring the array.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.n_metabolites","page":"Reference","title":"AbstractFBCModels.n_metabolites","text":"The number of metabolites in the given model. Must be equal to the length of the vector returned by metabolites, and may be more efficient for just determining the size.\n\n\n\n\n\n","category":"function"},{"location":"reference/#AbstractFBCModels.n_reactions-Tuple{AbstractFBCModels.AbstractFBCModel}","page":"Reference","title":"AbstractFBCModels.n_reactions","text":"n_reactions(a::AbstractFBCModels.AbstractFBCModel) -> Int64\n\n\nThe number of reactions in the given model. Must be equal to the length of the vector returned by reactions, and may be more efficient for just determining the size.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.objective-Tuple{AbstractFBCModels.AbstractFBCModel}","page":"Reference","title":"AbstractFBCModels.objective","text":"objective(\n    a::AbstractFBCModels.AbstractFBCModel\n) -> SparseArrays.SparseVector{Float64, Int64}\n\n\nGet the objective vector of the model.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.reaction_annotations-Tuple{AbstractFBCModels.AbstractFBCModel, String}","page":"Reference","title":"AbstractFBCModels.reaction_annotations","text":"reaction_annotations(\n    _::AbstractFBCModels.AbstractFBCModel,\n    reaction_id::String\n) -> Dict{String, Vector{String}}\n\n\nA dictionary of standardized names that may help identifying the reaction. The dictionary assigns vectors of possible identifiers to identifier system names, e.g. \"Reactome\" => [\"reactomeID123\"].\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.reaction_gene_association_dnf-Tuple{AbstractFBCModels.AbstractFBCModel, String}","page":"Reference","title":"AbstractFBCModels.reaction_gene_association_dnf","text":"reaction_gene_association_dnf(\n    _::AbstractFBCModels.AbstractFBCModel,\n    reaction_id::String\n) -> Union{Nothing, Vector{Vector{String}}}\n\n\nReturns the sets of genes that need to be present for the reaction to work in a DNF formula. This helps for constructively using the reaction-gene-association information.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.reaction_gene_products_available-Tuple{AbstractFBCModels.AbstractFBCModel, String, Function}","page":"Reference","title":"AbstractFBCModels.reaction_gene_products_available","text":"reaction_gene_products_available(\n    _::AbstractFBCModels.AbstractFBCModel,\n    reaction_id::String,\n    gene_product_available::Function\n) -> Union{Nothing, Bool}\n\n\nEvaluate whether the reaction can work given in a conditions given by the current availability of gene products, or nothing if the information is not recorded. The availability us queried via gene_products_available, which must be a function of a single String argument that returns Bool.\n\nGenerally it may be simpler to use reaction_gene_association_dnf, but in many models the complexity of the conversion to DNF is prohibitive.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.reaction_name-Tuple{AbstractFBCModels.AbstractFBCModel, String}","page":"Reference","title":"AbstractFBCModels.reaction_name","text":"reaction_name(\n    _::AbstractFBCModels.AbstractFBCModel,\n    reaction_id::String\n) -> Union{Nothing, String}\n\n\nName of the given reaction.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.reaction_notes-Tuple{AbstractFBCModels.AbstractFBCModel, String}","page":"Reference","title":"AbstractFBCModels.reaction_notes","text":"reaction_notes(\n    _::AbstractFBCModels.AbstractFBCModel,\n    reaction_id::String\n) -> Dict{String, Vector{String}}\n\n\nFree-text notes organized in a dictionary by topics about the given reaction in the model.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.reaction_stoichiometry-Tuple{AbstractFBCModels.AbstractFBCModel, String}","page":"Reference","title":"AbstractFBCModels.reaction_stoichiometry","text":"reaction_stoichiometry(\n    a::AbstractFBCModels.AbstractFBCModel,\n    reaction_id::String\n) -> Dict{String, Float64}\n\n\nThe stoichiometry of the given reaction as a dictionary maps the metabolite IDs to their stoichiometric coefficients.\n\nUsing this function may be more efficient in cases than loading the whole stoichiometry.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.reactions-Tuple{AbstractFBCModels.AbstractFBCModel}","page":"Reference","title":"AbstractFBCModels.reactions","text":"reactions(\n    a::AbstractFBCModels.AbstractFBCModel\n) -> Vector{String}\n\n\nReturn a vector of reaction identifiers in a model.\n\nFor technical reasons, the \"reactions\" may sometimes not be true reactions but various virtual and helper pseudo-reactions that are used in the metabolic modeling, such as metabolite exchanges, separated forward and reverse reaction directions, supplies of enzymatic and genetic material and virtual cell volume, etc.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.stoichiometry-Tuple{AbstractFBCModels.AbstractFBCModel}","page":"Reference","title":"AbstractFBCModels.stoichiometry","text":"stoichiometry(\n    a::AbstractFBCModels.AbstractFBCModel\n) -> SparseArrays.SparseMatrixCSC{Float64, Int64}\n\n\nThe sparse stoichiometric matrix of a given model.\n\nThis usually corresponds to all the equality constraints in the model. The matrix must be of size n_metabolites by n_reactions.\n\n\n\n\n\n","category":"method"},{"location":"reference/#IO-functions","page":"Reference","title":"IO functions","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [AbstractFBCModels]\nPages = [\"src/io.jl\"]","category":"page"},{"location":"reference/#AbstractFBCModels.eligible_model_types_for_filename-Tuple{String}","page":"Reference","title":"AbstractFBCModels.eligible_model_types_for_filename","text":"eligible_model_types_for_filename(path::String) -> Vector\n\n\nFind which of the known subtypes of AbstractFBCModel would typically be able to open the file at path, using information in filename_extensions.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.filename_extensions-Union{Tuple{Type{A}}, Tuple{A}} where A<:AbstractFBCModels.AbstractFBCModel","page":"Reference","title":"AbstractFBCModels.filename_extensions","text":"filename_extensions(\n    _::Type{A<:AbstractFBCModels.AbstractFBCModel}\n) -> Vector{String}\n\n\nA vector of filename extensions that are common for files that contain the given metabolic model type. This is used by load to guess the type of the model that should be loaded.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.guess_model_type_from_filename-Tuple{String}","page":"Reference","title":"AbstractFBCModels.guess_model_type_from_filename","text":"guess_model_type_from_filename(path::String) -> Any\n\n\nGuess which of the known subtypes of AbstractFBCModel would typically open the path (internally using eligible_model_types_for_filename for the purpose). Throws an error if the match is ambiguous or missing.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.load-Tuple{String}","page":"Reference","title":"AbstractFBCModels.load","text":"load(path::String) -> AbstractFBCModels.CanonicalModel.Model\n\n\nLoad a model from path. The type of the model is automatically guessed based on the filename extension. The guessing inspects all subtypes of AbstractFBCModel, thus always requires compilation – if possible, specify the proper type using the 2-parameter version of load to save time.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.load-Union{Tuple{A}, Tuple{Type{A}, String}} where A<:AbstractFBCModels.AbstractFBCModel","page":"Reference","title":"AbstractFBCModels.load","text":"load(\n    _::Type{A<:AbstractFBCModels.AbstractFBCModel},\n    path::String\n) -> AbstractFBCModels.CanonicalModel.Model\n\n\nLoad a model from path.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.save-Tuple{AbstractFBCModels.AbstractFBCModel, String}","page":"Reference","title":"AbstractFBCModels.save","text":"save(a::AbstractFBCModels.AbstractFBCModel, path::String)\n\n\nSave a model to the given path.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Miscellaneous-utilities","page":"Reference","title":"Miscellaneous utilities","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [AbstractFBCModels]\nPages = [\"src/utils.jl\"]","category":"page"},{"location":"reference/#AbstractFBCModels.accessors-Tuple{}","page":"Reference","title":"AbstractFBCModels.accessors","text":"accessors() -> Vector{Method}\n\n\nProvide a methodswith-style listing of accessors that the model implementors should implement.\n\nFor typesystem reasons, the list will not contain methods for save and filename_extensions that dispatch on type objects. You should implement these as well.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.check_cached_file_hash-Tuple{Any, Any}","page":"Reference","title":"AbstractFBCModels.check_cached_file_hash","text":"check_cached_file_hash(path, expected_checksum)\n\n\nCheck if the file at path has the expected hash.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.download_data_file-Tuple{Any, Any, Any}","page":"Reference","title":"AbstractFBCModels.download_data_file","text":"download_data_file(url, path, hash) -> Any\n\n\nDownload the file at url and save it at path, also check if this file is the expected file by calling check_cached_file_hash. If the file has already been downloaded, and stored at path, then it is not downloaded again.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.reaction_gene_products_available_from_dnf-Tuple{AbstractFBCModels.AbstractFBCModel, String, Function}","page":"Reference","title":"AbstractFBCModels.reaction_gene_products_available_from_dnf","text":"reaction_gene_products_available_from_dnf(\n    m::AbstractFBCModels.AbstractFBCModel,\n    reaction_id::String,\n    available::Function\n) -> Union{Nothing, Bool}\n\n\nUtility function to compute the value of reaction_gene_products_available for models that already implement reaction_gene_association_dnf.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.run_fbcmodel_file_tests-Union{Tuple{X}, Tuple{Type{X}, String}} where X<:AbstractFBCModels.AbstractFBCModel","page":"Reference","title":"AbstractFBCModels.run_fbcmodel_file_tests","text":"run_fbcmodel_file_tests(\n    ::Type{X<:AbstractFBCModels.AbstractFBCModel},\n    path::String;\n    name\n) -> Union{Test.FallbackTestSet, Test.DefaultTestSet}\n\n\nTest if the given model type loads properly from a file.\n\nThe function uses the testing infrastructure from Test to report problems – it is supposed to be a part of larger test-sets, preferably in all model implementation packages.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.run_fbcmodel_type_tests-Union{Tuple{Type{X}}, Tuple{X}} where X<:AbstractFBCModels.AbstractFBCModel","page":"Reference","title":"AbstractFBCModels.run_fbcmodel_type_tests","text":"run_fbcmodel_type_tests(\n    _::Type{X<:AbstractFBCModels.AbstractFBCModel}\n) -> Union{Test.FallbackTestSet, Test.DefaultTestSet}\n\n\nTest if the given model type works right.\n\nThe function uses the testing infrastructure from Test to report problems – it is supposed to be a part of larger test-sets, preferably in all model implementation packages.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Canonical-model-implementation","page":"Reference","title":"Canonical model implementation","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [AbstractFBCModels, AbstractFBCModels.CanonicalModel]\nPages = [\"src/canonical.jl\"]","category":"page"},{"location":"reference/#AbstractFBCModels.CanonicalModel.Gene","page":"Reference","title":"AbstractFBCModels.CanonicalModel.Gene","text":"mutable struct Gene\n\nA canonical Julia representation of a gene in the AbstractFBCModels interface.\n\nFields\n\nname::Union{Nothing, String}\nannotations::Dict{String, Vector{String}}\nnotes::Dict{String, Vector{String}}\n\n\n\n\n\n","category":"type"},{"location":"reference/#AbstractFBCModels.CanonicalModel.Metabolite","page":"Reference","title":"AbstractFBCModels.CanonicalModel.Metabolite","text":"mutable struct Metabolite\n\nA canonical Julia representation of a metabolite in the AbstractFBCModels interface.\n\nFields\n\nname::Union{Nothing, String}\ncompartment::Union{Nothing, String}\nformula::Union{Nothing, Dict{String, Int64}}\ncharge::Union{Nothing, Int64}\nbalance::Float64\nannotations::Dict{String, Vector{String}}\nnotes::Dict{String, Vector{String}}\n\n\n\n\n\n","category":"type"},{"location":"reference/#AbstractFBCModels.CanonicalModel.Model","page":"Reference","title":"AbstractFBCModels.CanonicalModel.Model","text":"struct Model <: AbstractFBCModels.AbstractFBCModel\n\nA canonical Julia representation of a metabolic model that sotres exactly the data represented by AbstractFBCModels accessors.\n\nThe implementation is useful for manipulating model data manually without writing new model types, or even for constructing models from base data in many simple cases.\n\nAdditionally, you can use the implementation of accessors for this model type in the source code of AbstractFBCModels as a starting point for creating an AbstractFBCModel interface for your own models.\n\nFields\n\nreactions::Dict{String, AbstractFBCModels.CanonicalModel.Reaction}\nmetabolites::Dict{String, AbstractFBCModels.CanonicalModel.Metabolite}\ngenes::Dict{String, AbstractFBCModels.CanonicalModel.Gene}\n\n\n\n\n\n","category":"type"},{"location":"reference/#AbstractFBCModels.CanonicalModel.Reaction","page":"Reference","title":"AbstractFBCModels.CanonicalModel.Reaction","text":"mutable struct Reaction\n\nA canonical Julia representation of a reaction in the AbstractFBCModels interface.\n\nFields\n\nname::Union{Nothing, String}\nlower_bound::Float64\nupper_bound::Float64\nstoichiometry::Dict{String, Float64}\nobjective_coefficient::Float64\ngene_association_dnf::Union{Nothing, Vector{Vector{String}}}\nannotations::Dict{String, Vector{String}}\nnotes::Dict{String, Vector{String}}\n\n\n\n\n\n","category":"type"},{"location":"#AbstractFBCModels.jl","page":"README","title":"AbstractFBCModels.jl","text":"","category":"section"},{"location":"","page":"README","title":"README","text":"Modules = [AbstractFBCModels]\nPages = [\"src/AbstractFBCModels.jl\"]","category":"page"},{"location":"#AbstractFBCModels.AbstractFBCModels","page":"README","title":"AbstractFBCModels.AbstractFBCModels","text":"AbstractFBCModels.jl – Common interface for flux-balanced constrained models\n\nBuild status Documentation\n(Image: CI) (Image: codecov) (Image: stable documentation) (Image: dev documentation)\n\nPackage AbstractFBCModels.jl defines a set of accessor functions that provide a generic API for working with the contents of the constraint-based metabolic (or \"Flux-Balanced Constrained\" for FBC) models. Packages that work with model formats may implement the API to transparently expose the contents of the models in given format to many other packages.\n\nThe primary purpose of this is to provide the model loading functionality for COBREXA.jl and FBCModelTests.jl, but is otherwise completely generic and can be used independently of these packages.\n\nThe package is currently quite new, maintained and open for extensions; feel free to discuss changes and ideas via issues and pull requests.\n\nAcknowledgements\n\nAbstractFBCModels.jl was developed at the Luxembourg Centre for Systems Biomedicine of the University of Luxembourg (uni.lu/lcsb) and at Institute for Quantitative and Theoretical Biology at Heinrich Heine University Düsseldorf (qtb.hhu.de). The development was supported by European Union's Horizon 2020 Programme under PerMedCoE project (permedcoe.eu), agreement no. 951773.\n\n<img src=\"docs/src/assets/unilu.svg\" alt=\"Uni.lu logo\" height=\"64px\">   <img src=\"docs/src/assets/lcsb.svg\" alt=\"LCSB logo\" height=\"64px\">   <img src=\"docs/src/assets/hhu.svg\" alt=\"HHU logo\" height=\"64px\" style=\"height:64px; width:auto\">   <img src=\"docs/src/assets/qtb.svg\" alt=\"QTB logo\" height=\"64px\" style=\"height:64px; width:auto\">   <img src=\"docs/src/assets/permedcoe.svg\" alt=\"PerMedCoE logo\" height=\"64px\">\n\n\n\n\n\n","category":"module"}]
}
