var documenterSearchIndex = {"docs":
[{"location":"canonical/","page":"Implementing new model types","title":"Implementing new model types","text":"EditURL = \"canonical.jl\"","category":"page"},{"location":"canonical/#Implementing-new-model-types","page":"Implementing new model types","title":"Implementing new model types","text":"","category":"section"},{"location":"canonical/","page":"Implementing new model types","title":"Implementing new model types","text":"For convenience, AbstractFBCModels defines a \"canonical\" implementation of a FBC model: a completely generic data structure that can store exactly the complete information that is representable by the AbstractFBCModel accessors, and nothing else.","category":"page"},{"location":"canonical/","page":"Implementing new model types","title":"Implementing new model types","text":"The type is not useful for actually constructing the models, but may serve a good purpose in several other cases:","category":"page"},{"location":"canonical/","page":"Implementing new model types","title":"Implementing new model types","text":"If you need an \"intermediate step\" when converting complicated FBC models to other types, the canonical model is guaranteed not to lose any information, yet perform relatively well when re-exporting the information via the accessors.\nIf you need to make quick modifications to another model type that does not admin easy mutation (e.g., it is made of immutable structs), you can convert to the canonical model and make the small fixes in there.\nHere, we use it for describing how to \"perform\" your own definition of model type, and demonstrate the use of the pre-defined testing framework on it.","category":"page"},{"location":"canonical/","page":"Implementing new model types","title":"Implementing new model types","text":"The model is available for use as AbstractFBCModels.CanonicalModel.Model","category":"page"},{"location":"canonical/#Defining-the-model","page":"Implementing new model types","title":"Defining the model","text":"","category":"section"},{"location":"canonical/","page":"Implementing new model types","title":"Implementing new model types","text":"For convenience in the later explanation, we list the whole definition of the module here:","category":"page"},{"location":"canonical/","page":"Implementing new model types","title":"Implementing new model types","text":"\nmodule CanonicalModel\n\nusing DocStringExtensions\n\nimport ..AbstractFBCModels as A\nimport Serialization as S\nimport SparseArrays: sparse, findnz\n\n\"\"\"\n$(TYPEDEF)\n\nA canonical Julia representation of a reaction in the `AbstractFBCModels` interface.\n\n# Fields\n$(TYPEDFIELDS)\n\"\"\"\nBase.@kwdef mutable struct Reaction\n    name::A.Maybe{String} = nothing\n    lower_bound::Float64 = -Inf\n    upper_bound::Float64 = Inf\n    stoichiometry::Dict{String,Float64} = Dict()\n    objective_coefficient::Float64 = 0.0\n    gene_association_dnf::A.Maybe{A.GeneAssociationDNF} = nothing\n    annotations::A.Annotations = A.Annotations()\n    notes::A.Notes = A.Notes()\nend\n\nBase.show(io::Base.IO, ::MIME\"text/plain\", x::Reaction) = A.pretty_print_kwdef(io, x)\n\n\"\"\"\n$(TYPEDEF)\n\nA canonical Julia representation of a metabolite in the `AbstractFBCModels` interface.\n\n# Fields\n$(TYPEDFIELDS)\n\"\"\"\nBase.@kwdef mutable struct Metabolite\n    name::A.Maybe{String} = nothing\n    compartment::A.Maybe{String} = nothing\n    formula::A.Maybe{A.MetaboliteFormula} = nothing\n    charge::A.Maybe{Int} = nothing\n    balance::Float64 = 0.0\n    annotations::A.Annotations = A.Annotations()\n    notes::A.Notes = A.Notes()\nend\n\nBase.show(io::Base.IO, ::MIME\"text/plain\", x::Metabolite) = A.pretty_print_kwdef(io, x)\n\n\"\"\"\n$(TYPEDEF)\n\nA canonical Julia representation of a gene in the `AbstractFBCModels` interface.\n\n# Fields\n$(TYPEDFIELDS)\n\"\"\"\nBase.@kwdef mutable struct Gene\n    name::A.Maybe{String} = nothing\n    annotations::A.Annotations = A.Annotations()\n    notes::A.Notes = A.Notes()\nend\n\nBase.show(io::Base.IO, ::MIME\"text/plain\", x::Gene) = A.pretty_print_kwdef(io, x)\n\n\"\"\"\n$(TYPEDEF)\n\nA canonical Julia representation of a metabolic model that sotres exactly the\ndata represented by `AbstractFBCModels` accessors.\n\nThe implementation is useful for manipulating model data manually without\nwriting new model types, or even for constructing models from base data in many\nsimple cases.\n\nAdditionally, you can use the implementation of accessors for this model type\nin the source code of `AbstractFBCModels` as a starting point for creating an\n`AbstractFBCModel` interface for your own models.\n\n# Fields\n$(TYPEDFIELDS)\n\"\"\"\nBase.@kwdef struct Model <: A.AbstractFBCModel\n    reactions::Dict{String,Reaction} = Dict()\n    metabolites::Dict{String,Metabolite} = Dict()\n    genes::Dict{String,Gene} = Dict()\nend\n\nBase.show(io::Base.IO, ::MIME\"text/plain\", x::Model) = A.pretty_print_kwdef(io, x)\n\nA.reactions(m::Model) = sort(collect(keys(m.reactions)))\nA.metabolites(m::Model) = sort(collect(keys(m.metabolites)))\nA.genes(m::Model) = sort(collect(keys(m.genes)))\nA.n_reactions(m::Model) = length(m.reactions)\nA.n_metabolites(m::Model) = length(m.metabolites)\nA.n_genes(m::Model) = length(m.genes)\nA.reaction_name(m::Model, id::String) = m.reactions[id].name\nA.metabolite_name(m::Model, id::String) = m.metabolites[id].name\nA.gene_name(m::Model, id::String) = m.genes[id].name\nA.reaction_annotations(m::Model, id::String) = m.reactions[id].annotations\nA.metabolite_annotations(m::Model, id::String) = m.metabolites[id].annotations\nA.gene_annotations(m::Model, id::String) = m.genes[id].annotations\nA.reaction_notes(m::Model, id::String) = m.reactions[id].notes\nA.metabolite_notes(m::Model, id::String) = m.metabolites[id].notes\nA.gene_notes(m::Model, id::String) = m.genes[id].notes\n\nfunction A.stoichiometry(m::Model)\n    midxs = Dict(mid => idx for (idx, (mid, _)) in enumerate(m.metabolites))\n    I = Int[]\n    J = Int[]\n    V = Float64[]\n    for (ridx, (_, r)) in enumerate(m.reactions)\n        for (smid, v) in r.stoichiometry\n            push!(I, midxs[smid])\n            push!(J, ridx)\n            push!(V, v)\n        end\n    end\n    sparse(I, J, V, length(m.metabolites), length(m.reactions))\nend\n\nA.bounds(m::Model) = (\n    [m.reactions[rid].lower_bound for rid in A.reactions(m)],\n    [m.reactions[rid].upper_bound for rid in A.reactions(m)],\n)\n\nA.balance(m::Model) =\n    sparse(Float64[m.metabolites[mid].balance for mid in A.metabolites(m)])\nA.objective(m::Model) =\n    sparse(Float64[m.reactions[rid].objective_coefficient for rid in A.reactions(m)])\n\nA.reaction_gene_association_dnf(m::Model, id::String) = m.reactions[id].gene_association_dnf\nA.reaction_gene_products_available(m::Model, id::String, fn::Function) =\n    A.reaction_gene_products_available_from_dnf(m, id, fn)\nA.reaction_stoichiometry(m::Model, id::String) = m.reactions[id].stoichiometry\n\nA.metabolite_formula(m::Model, id::String) = m.metabolites[id].formula\nA.metabolite_charge(m::Model, id::String) = m.metabolites[id].charge\nA.metabolite_compartment(m::Model, id::String) = m.metabolites[id].compartment\n\nA.load(::Type{Model}, path::String)::Model = S.deserialize(path)\nA.save(m::Model, path::String) = S.serialize(path, m)\nA.filename_extensions(::Type{Model}) = [\"canonical-serialized-fbc\"]\n\nfunction Base.convert(::Type{Model}, x::A.AbstractFBCModel)\n    (lbs, ubs) = A.bounds(x)\n    os = A.objective(x)\n    bs = A.balance(x)\n    mets = A.metabolites(x)\n    Model(\n        reactions = Dict(\n            r => Reaction(\n                name = A.reaction_name(x, r),\n                lower_bound = lb,\n                upper_bound = ub,\n                stoichiometry = A.reaction_stoichiometry(x, r),\n                gene_association_dnf = A.reaction_gene_association_dnf(x, r),\n                annotations = A.reaction_annotations(x, r),\n                notes = A.reaction_notes(x, r),\n            ) for (r, lb, ub) in zip(A.reactions(x), lbs, ubs)\n        ),\n        metabolites = Dict(\n            m => Metabolite(\n                name = A.metabolite_name(x, m),\n                balance = b,\n                formula = A.metabolite_formula(x, m),\n                charge = A.metabolite_charge(x, m),\n                compartment = A.metabolite_compartment(x, m),\n                annotations = A.metabolite_annotations(x, m),\n                notes = A.metabolite_notes(x, m),\n            ) for (m, b) in zip(mets, bs)\n        ),\n        genes = Dict(\n            g => Gene(\n                name = A.gene_name(x, g),\n                annotations = A.gene_annotations(x, g),\n                notes = A.gene_notes(x, g),\n            ) for g in A.genes(x)\n        ),\n    )\nend\n\nend # module CanonicalModel","category":"page"},{"location":"canonical/","page":"Implementing new model types","title":"Implementing new model types","text":"The definition contains several main parts:","category":"page"},{"location":"canonical/","page":"Implementing new model types","title":"Implementing new model types","text":"the data structures for the model and all the main parts\noverloaded accessors that provide generic access for the things in the model\noverloaded loading and saving functions, together with the declaration of the common model suffixes\na conversion function that can extract data using accessors from any other AbstractFBCModel and construct the canonical model.","category":"page"},{"location":"canonical/","page":"Implementing new model types","title":"Implementing new model types","text":"Notably, the default file extension is chosen as very unwieldy so that no one ever really exchanges data using this model type.","category":"page"},{"location":"canonical/#Testing-your-model-definition","page":"Implementing new model types","title":"Testing your model definition","text":"","category":"section"},{"location":"canonical/","page":"Implementing new model types","title":"Implementing new model types","text":"Apart from making sure that the accessors work by usual unit tests, you can use 2 testing functions that scrutinize the expected properties of the model type both solely as a type, and using an example model file. These allow you to discover potential problems, as well as build a self-updating test suite for your model that provides long-term sustainability and quality assurance.","category":"page"},{"location":"canonical/#Running-type-level-tests","page":"Implementing new model types","title":"Running type-level tests","text":"","category":"section"},{"location":"canonical/","page":"Implementing new model types","title":"Implementing new model types","text":"Typically, the test suite would run the following to check if types of everything match the expectations.","category":"page"},{"location":"canonical/","page":"Implementing new model types","title":"Implementing new model types","text":"import AbstractFBCModels as A\nimport AbstractFBCModels.CanonicalModel: Model\n\nA.run_fbcmodel_type_tests(Model);\nnothing #hide","category":"page"},{"location":"canonical/#Making-a-simple-model-for-value-tests","page":"Implementing new model types","title":"Making a simple model for value tests","text":"","category":"section"},{"location":"canonical/","page":"Implementing new model types","title":"Implementing new model types","text":"For testing the values, you need to provide an existing file that contains the model. Let's create some contents first:","category":"page"},{"location":"canonical/","page":"Implementing new model types","title":"Implementing new model types","text":"import AbstractFBCModels.CanonicalModel: Reaction, Metabolite, Gene\n\nm = Model()\nm.metabolites[\"m1\"] = Metabolite(compartment = \"inside\")\nm.metabolites[\"m2\"] = Metabolite(compartment = \"outside\")\nm.genes[\"g1\"] = Gene()\nm.genes[\"g2\"] = Gene()\nm.reactions[\"forward\"] = Reaction(\n    name = \"import\",\n    stoichiometry = Dict(\"m1\" => -1.0, \"m2\" => 1.0),\n    gene_association_dnf = [[\"g1\"], [\"g2\"]],\n)\nm.reactions[\"and_back\"] =\n    Reaction(name = \"export\", stoichiometry = Dict(\"m2\" => -1.0, \"m1\" => 1.0))\nm.reactions[\"exchange1\"] = Reaction(\n    name = \"exchange m1\",\n    stoichiometry = Dict(\"m1\" => -1.0),\n    gene_association_dnf = [[]], # DNF encoding of a reaction that requires no gene products\n)\nm.reactions[\"exchange2\"] = Reaction(\n    name = \"exchange m2\",\n    stoichiometry = Dict(\"m2\" => -1.0),\n    gene_association_dnf = [], # DNF encoding of a reaction that never has gene products available\n)\nnothing #hide","category":"page"},{"location":"canonical/","page":"Implementing new model types","title":"Implementing new model types","text":"We should immediately find the basic accessors working:","category":"page"},{"location":"canonical/","page":"Implementing new model types","title":"Implementing new model types","text":"A.stoichiometry(m)","category":"page"},{"location":"canonical/","page":"Implementing new model types","title":"Implementing new model types","text":"We can check various side things, such as which reactions would and would not work given all gene products disappear:","category":"page"},{"location":"canonical/","page":"Implementing new model types","title":"Implementing new model types","text":"products_available = [\n    A.reaction_gene_products_available(m, rid, _ -> false) for\n    rid in [\"forward\", \"and_back\", \"exchange1\", \"exchange2\"]\n]","category":"page"},{"location":"canonical/","page":"Implementing new model types","title":"Implementing new model types","text":"We can now also write the model to disk and try to load it with the default loading function:","category":"page"},{"location":"canonical/","page":"Implementing new model types","title":"Implementing new model types","text":"mktempdir() do dir\n    path = joinpath(dir, \"model.canonical-serialized-fbc\")\n    A.save(m, path)\n    A.load(path)\nend","category":"page"},{"location":"canonical/#Running-the-value-tests","page":"Implementing new model types","title":"Running the value tests","text":"","category":"section"},{"location":"canonical/","page":"Implementing new model types","title":"Implementing new model types","text":"Given the data, value tests have an opportunity to scrutinize much greater amount of properties of the model implementation.","category":"page"},{"location":"canonical/","page":"Implementing new model types","title":"Implementing new model types","text":"Running the tests requires a model type and an \"example\" model file:","category":"page"},{"location":"canonical/","page":"Implementing new model types","title":"Implementing new model types","text":"mktempdir() do dir\n    path = joinpath(dir, \"model.canonical-serialized-fbc\")\n    A.save(m, path)\n    A.run_fbcmodel_file_tests(Model, path, name = \"small model\")\nend;\nnothing #hide","category":"page"},{"location":"canonical/","page":"Implementing new model types","title":"Implementing new model types","text":"","category":"page"},{"location":"canonical/","page":"Implementing new model types","title":"Implementing new model types","text":"This page was generated using Literate.jl.","category":"page"},{"location":"utilities/","page":"Utility functions","title":"Utility functions","text":"EditURL = \"utilities.jl\"","category":"page"},{"location":"utilities/#Utility-functions","page":"Utility functions","title":"Utility functions","text":"","category":"section"},{"location":"utilities/","page":"Utility functions","title":"Utility functions","text":"AbstractFBCModels export several utilities for easier definition of the model contents; here we explore some of them in individual sections.","category":"page"},{"location":"utilities/","page":"Utility functions","title":"Utility functions","text":"import AbstractFBCModels as A","category":"page"},{"location":"utilities/#Which-accessors-should-I-overload?","page":"Utility functions","title":"Which accessors should I overload?","text":"","category":"section"},{"location":"utilities/","page":"Utility functions","title":"Utility functions","text":"You can query the current set of accessor functions as follows:","category":"page"},{"location":"utilities/","page":"Utility functions","title":"Utility functions","text":"A.accessors()","category":"page"},{"location":"utilities/","page":"Utility functions","title":"Utility functions","text":"You do not need to overload all of them (e.g., if you model does not have any genes you can completely omit all gene-related functions). The main required ones (esp. the reaction- and metabolite-related ones) will throw an error if not implemented, and the automated tests will fail with them.","category":"page"},{"location":"utilities/#Why-are-there-2-representations-of-gene-reaction-associations?","page":"Utility functions","title":"Why are there 2 representations of gene-reaction associations?","text":"","category":"section"},{"location":"utilities/","page":"Utility functions","title":"Utility functions","text":"Gene-reaction association is, in general, a Boolean function – you give it a list of genes that are available (or, symmetrically, knocked out) and a reaction, and it tells you whether the reaction can work or not. This representation is captured in accessor reaction_gene_products_available.","category":"page"},{"location":"utilities/","page":"Utility functions","title":"Utility functions","text":"Some model construction methods, on the other hand, require a relatively streamlined view of the gene-reaction associations, roughly describing \"ways in which several possible enzymes that catalyze the reaction can be assembled from individual gene products\" – these are sometimes dubbed \"isozymes\". This view is isomorphic to a Boolean formula in a disjunctive normal form (DNF) (put simply, a DNF would be \"a big OR of ANDed identifiers\", such as (a && b && c) || (a && d)). The DNF view of the gene association is accessed via reaction_gene_association_dnf.","category":"page"},{"location":"utilities/","page":"Utility functions","title":"Utility functions","text":"Both representations have pros and cons; the main can be summarized as follows:","category":"page"},{"location":"utilities/","page":"Utility functions","title":"Utility functions","text":"DNF may not be able to represent some valid boolean formulas without an exponential explosion in size – in particular, the formula (a1||b1) && (a2||b2) && (a3||b3) && ... && (aN||bN) will explode to roughly 2^N terms in DNF.\nThere's no simple universal format to store and exchange the descriptions of general boolean functions; we thus do not want to enforce a single one.","category":"page"},{"location":"utilities/","page":"Utility functions","title":"Utility functions","text":"Your model is primarily supposed to overload the reaction_gene_products_available accessor. If you are able to reliably convert your Boolean functions to DNF, you should also overload the reaction_gene_association_dnf.","category":"page"},{"location":"utilities/","page":"Utility functions","title":"Utility functions","text":"In some cases when the model directly stores the DNF form, you may also utilize the reaction_gene_products_available_from_dnf function to easily implement the reactiongeneproducts_available` by just forwarding the arguments.","category":"page"},{"location":"utilities/#Downloading-models-for-testing","page":"Utility functions","title":"Downloading models for testing","text":"","category":"section"},{"location":"utilities/","page":"Utility functions","title":"Utility functions","text":"For reproducibility, it is often viable to check downloaded files for validity, using e.g. checksums. Since this is a common operation, we provide download_data_file, which is an appropriate wrapper for Downloads.download:","category":"page"},{"location":"utilities/","page":"Utility functions","title":"Utility functions","text":"mktempdir() do dir\n    origin = joinpath(dir, \"origin\")\n    url = \"file://$origin\"\n    dest = joinpath(dir, \"model\")\n    open(origin, \"w\") do f\n        write(f, \"hello\")\n    end\n    A.download_data_file(\n        url,\n        dest,\n        \"2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\",\n    )\nend","category":"page"},{"location":"utilities/","page":"Utility functions","title":"Utility functions","text":"","category":"page"},{"location":"utilities/","page":"Utility functions","title":"Utility functions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Types","page":"Reference","title":"Types","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [AbstractFBCModels]\nPages = [\"src/types.jl\"]","category":"page"},{"location":"reference/#AbstractFBCModels.Maybe","page":"Reference","title":"AbstractFBCModels.Maybe","text":"A nice name for a \"nullable\" type.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AbstractFBCModels.AbstractFBCModel","page":"Reference","title":"AbstractFBCModels.AbstractFBCModel","text":"abstract type AbstractFBCModel\n\nA supertype of all Flux-balance-Based Constrained metabolic models that share the common interface defined by AbstractFBCModels.jl.\n\nTo use the interface for your type, make it a subtype of AbstractFBCModel and provide methods for various functions used with the model. Use accessors to find the current list of methods, and utilize run_fbcmodel_type_tests and run_fbcmodel_file_tests to test the completeness and compatibility of your implementation with the assumptions of the interface.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AbstractFBCModels.Annotations","page":"Reference","title":"AbstractFBCModels.Annotations","text":"Annotations = Dict{String,Vector{String}}\n\nDictionary used to store (possible multiple) standardized annotations of something, such as a metabolite or a reaction (as listed by metabolites and reactions).\n\nExample\n\nAnnotations(\"PubChem\" => [\"CID12345\", \"CID54321\"])\n\n\n\n\n\n","category":"type"},{"location":"reference/#AbstractFBCModels.GeneAssociationDNF","page":"Reference","title":"AbstractFBCModels.GeneAssociationDNF","text":"GeneAssociationDNF = Vector{Vector{String}}\n\nDisjunctive normal form of simple gene associations. For example, [[A, B], [B]] represents two possibilities to run a given reaction, where the first requires both gene products A and B, while the second possibility only requires gene product C.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AbstractFBCModels.MetaboliteFormula","page":"Reference","title":"AbstractFBCModels.MetaboliteFormula","text":"MetaboliteFormula = Dict{String,Int}\n\nDictionary of atoms and their abundances in a molecule.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AbstractFBCModels.Notes","page":"Reference","title":"AbstractFBCModels.Notes","text":"Notes = Dict{String,Vector{String}}\n\nFree-form notes about something (e.g. a gene listed by genes), categorized by \"topic\".\n\n\n\n\n\n","category":"type"},{"location":"reference/#AbstractFBCModels.SparseMat","page":"Reference","title":"AbstractFBCModels.SparseMat","text":"A shortname for a sparse matrix.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AbstractFBCModels.SparseVec","page":"Reference","title":"AbstractFBCModels.SparseVec","text":"A shortname for a sparse vector.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Model-content-accessors","page":"Reference","title":"Model content accessors","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [AbstractFBCModels]\nPages = [\"src/accessors.jl\"]","category":"page"},{"location":"reference/#AbstractFBCModels.balance-Tuple{AbstractFBCModels.AbstractFBCModel}","page":"Reference","title":"AbstractFBCModels.balance","text":"balance(\n    a::AbstractFBCModels.AbstractFBCModel\n) -> SparseArrays.SparseVector{Float64, Int64}\n\n\nGet the sparse balance vector of a model, which usually corresponds to the accumulation term associated with stoichiometric matrix.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.bounds-Tuple{AbstractFBCModels.AbstractFBCModel}","page":"Reference","title":"AbstractFBCModels.bounds","text":"bounds(\n    a::AbstractFBCModels.AbstractFBCModel\n) -> Tuple{Vector{Float64}, Vector{Float64}}\n\n\nGet the lower and upper bounds of all reactions in a model.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.gene_annotations-Tuple{AbstractFBCModels.AbstractFBCModel, String}","page":"Reference","title":"AbstractFBCModels.gene_annotations","text":"gene_annotations(\n    _::AbstractFBCModels.AbstractFBCModel,\n    gene_id::String\n) -> Dict{String, Vector{String}}\n\n\nA dictionary of standardized names that identify the corresponding gene or product. The dictionary assigns vectors of possible identifiers to identifier system names, such as \"PDB\" => [\"PROT01\"].\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.gene_name-Tuple{AbstractFBCModels.AbstractFBCModel, String}","page":"Reference","title":"AbstractFBCModels.gene_name","text":"gene_name(\n    _::AbstractFBCModels.AbstractFBCModel,\n    gene_id::String\n) -> Union{Nothing, String}\n\n\nThe name of the given gene in the model, if recorded.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.gene_notes-Tuple{AbstractFBCModels.AbstractFBCModel, String}","page":"Reference","title":"AbstractFBCModels.gene_notes","text":"gene_notes(\n    _::AbstractFBCModels.AbstractFBCModel,\n    gene_id::String\n) -> Dict{String, Vector{String}}\n\n\nFree-text notes organized in a dictionary by topics about the given gene in the model.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.genes-Tuple{AbstractFBCModels.AbstractFBCModel}","page":"Reference","title":"AbstractFBCModels.genes","text":"genes(\n    a::AbstractFBCModels.AbstractFBCModel\n) -> Vector{String}\n\n\nReturn identifiers of all genes contained in the model. Empty if none.\n\nGenes are also sometimes called \"gene products\" but we write genes for simplicity.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.metabolite_annotations-Tuple{AbstractFBCModels.AbstractFBCModel, String}","page":"Reference","title":"AbstractFBCModels.metabolite_annotations","text":"metabolite_annotations(\n    _::AbstractFBCModels.AbstractFBCModel,\n    metabolite_id::String\n) -> Dict{String, Vector{String}}\n\n\nA dictionary of standardized names that may help to identify the metabolite. The dictionary should assigns vectors of possible identifiers to identifier system names, such as \"ChEMBL\" => [\"123\"] or \"PubChem\" => [\"CID123\", \"CID654645645\"].\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.metabolite_charge-Tuple{AbstractFBCModels.AbstractFBCModel, String}","page":"Reference","title":"AbstractFBCModels.metabolite_charge","text":"metabolite_charge(\n    _::AbstractFBCModels.AbstractFBCModel,\n    metabolite_id::String\n) -> Union{Nothing, Int64}\n\n\nThe charge of the given metabolite in the model, or nothing in case the charge is not recorded.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.metabolite_compartment-Tuple{AbstractFBCModels.AbstractFBCModel, String}","page":"Reference","title":"AbstractFBCModels.metabolite_compartment","text":"metabolite_compartment(\n    _::AbstractFBCModels.AbstractFBCModel,\n    metabolite_id::String\n) -> Union{Nothing, String}\n\n\nThe compartment of the given metabolite in the model. nothing if no compartment is assigned.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.metabolite_formula-Tuple{AbstractFBCModels.AbstractFBCModel, String}","page":"Reference","title":"AbstractFBCModels.metabolite_formula","text":"metabolite_formula(\n    _::AbstractFBCModels.AbstractFBCModel,\n    metabolite_id::String\n) -> Union{Nothing, Dict{String, Int64}}\n\n\nThe formula of the given metabolite in the model, or nothing in case the formula is not recorded.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.metabolite_name-Tuple{AbstractFBCModels.AbstractFBCModel, String}","page":"Reference","title":"AbstractFBCModels.metabolite_name","text":"metabolite_name(\n    _::AbstractFBCModels.AbstractFBCModel,\n    metabolite_id::String\n) -> Union{Nothing, String}\n\n\nThe name of the given metabolite, if assigned.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.metabolite_notes-Tuple{AbstractFBCModels.AbstractFBCModel, String}","page":"Reference","title":"AbstractFBCModels.metabolite_notes","text":"metabolite_notes(\n    _::AbstractFBCModels.AbstractFBCModel,\n    metabolite_id::String\n) -> Dict{String, Vector{String}}\n\n\nFree-text notes organized in a dictionary by topics about the given metabolite in the model.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.metabolites-Tuple{AbstractFBCModels.AbstractFBCModel}","page":"Reference","title":"AbstractFBCModels.metabolites","text":"metabolites(\n    a::AbstractFBCModels.AbstractFBCModel\n) -> Vector{String}\n\n\nReturn a vector of metabolite identifiers in a model.\n\nAs with reactions, some metabolites in models may be virtual, representing purely technical equality constraints.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.n_genes-Tuple{AbstractFBCModels.AbstractFBCModel}","page":"Reference","title":"AbstractFBCModels.n_genes","text":"n_genes(a::AbstractFBCModels.AbstractFBCModel) -> Int64\n\n\nThe number of genes in the model (must be equal to the length of vector given by genes).\n\nThis may be more efficient than calling genes and measuring the array.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.n_metabolites","page":"Reference","title":"AbstractFBCModels.n_metabolites","text":"The number of metabolites in the given model. Must be equal to the length of the vector returned by metabolites, and may be more efficient for just determining the size.\n\n\n\n\n\n","category":"function"},{"location":"reference/#AbstractFBCModels.n_reactions-Tuple{AbstractFBCModels.AbstractFBCModel}","page":"Reference","title":"AbstractFBCModels.n_reactions","text":"n_reactions(a::AbstractFBCModels.AbstractFBCModel) -> Int64\n\n\nThe number of reactions in the given model. Must be equal to the length of the vector returned by reactions, and may be more efficient for just determining the size.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.objective-Tuple{AbstractFBCModels.AbstractFBCModel}","page":"Reference","title":"AbstractFBCModels.objective","text":"objective(\n    a::AbstractFBCModels.AbstractFBCModel\n) -> SparseArrays.SparseVector{Float64, Int64}\n\n\nGet the objective vector of the model.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.reaction_annotations-Tuple{AbstractFBCModels.AbstractFBCModel, String}","page":"Reference","title":"AbstractFBCModels.reaction_annotations","text":"reaction_annotations(\n    _::AbstractFBCModels.AbstractFBCModel,\n    reaction_id::String\n) -> Dict{String, Vector{String}}\n\n\nA dictionary of standardized names that may help identifying the reaction. The dictionary assigns vectors of possible identifiers to identifier system names, e.g. \"Reactome\" => [\"reactomeID123\"].\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.reaction_gene_association_dnf-Tuple{AbstractFBCModels.AbstractFBCModel, String}","page":"Reference","title":"AbstractFBCModels.reaction_gene_association_dnf","text":"reaction_gene_association_dnf(\n    _::AbstractFBCModels.AbstractFBCModel,\n    reaction_id::String\n) -> Union{Nothing, Vector{Vector{String}}}\n\n\nReturns the sets of genes that need to be present for the reaction to work in a DNF formula. This helps for constructively using the reaction-gene-association information.\n\nIf a model overloads this function, it must also properly overload reaction_gene_products_available. You can use reaction_gene_products_available_from_dnf as a helper for computing the availability from an existing overload of reaction_gene_association_dnf.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.reaction_gene_products_available-Tuple{AbstractFBCModels.AbstractFBCModel, String, Function}","page":"Reference","title":"AbstractFBCModels.reaction_gene_products_available","text":"reaction_gene_products_available(\n    _::AbstractFBCModels.AbstractFBCModel,\n    reaction_id::String,\n    gene_product_available::Function\n) -> Union{Nothing, Bool}\n\n\nEvaluate whether the reaction can work given in a conditions given by the current availability of gene products, or nothing if the information is not recorded. The availability us queried via gene_products_available, which must be a function of a single String argument that returns Bool.\n\nGenerally it may be simpler to use reaction_gene_association_dnf, but in many models the complexity of the conversion to DNF is prohibitive.\n\nFor generality reasons, this must be properly overloaded for all models that overload reaction_gene_association_dnf. Implementations may define reaction_gene_products_available_from_dnf to derive a valid implementation from an existing overload of reaction_gene_association_dnf.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.reaction_name-Tuple{AbstractFBCModels.AbstractFBCModel, String}","page":"Reference","title":"AbstractFBCModels.reaction_name","text":"reaction_name(\n    _::AbstractFBCModels.AbstractFBCModel,\n    reaction_id::String\n) -> Union{Nothing, String}\n\n\nName of the given reaction.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.reaction_notes-Tuple{AbstractFBCModels.AbstractFBCModel, String}","page":"Reference","title":"AbstractFBCModels.reaction_notes","text":"reaction_notes(\n    _::AbstractFBCModels.AbstractFBCModel,\n    reaction_id::String\n) -> Dict{String, Vector{String}}\n\n\nFree-text notes organized in a dictionary by topics about the given reaction in the model.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.reaction_stoichiometry-Tuple{AbstractFBCModels.AbstractFBCModel, String}","page":"Reference","title":"AbstractFBCModels.reaction_stoichiometry","text":"reaction_stoichiometry(\n    a::AbstractFBCModels.AbstractFBCModel,\n    reaction_id::String\n) -> Dict{String, Float64}\n\n\nThe stoichiometry of the given reaction as a dictionary maps the metabolite IDs to their stoichiometric coefficients.\n\nUsing this function may be more efficient in cases than loading the whole stoichiometry.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.reactions-Tuple{AbstractFBCModels.AbstractFBCModel}","page":"Reference","title":"AbstractFBCModels.reactions","text":"reactions(\n    a::AbstractFBCModels.AbstractFBCModel\n) -> Vector{String}\n\n\nReturn a vector of reaction identifiers in a model.\n\nFor technical reasons, the \"reactions\" may sometimes not be true reactions but various virtual and helper pseudo-reactions that are used in the metabolic modeling, such as metabolite exchanges, separated forward and reverse reaction directions, supplies of enzymatic and genetic material and virtual cell volume, etc.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.stoichiometry-Tuple{AbstractFBCModels.AbstractFBCModel}","page":"Reference","title":"AbstractFBCModels.stoichiometry","text":"stoichiometry(\n    a::AbstractFBCModels.AbstractFBCModel\n) -> SparseArrays.SparseMatrixCSC{Float64, Int64}\n\n\nThe sparse stoichiometric matrix of a given model.\n\nThis usually corresponds to all the equality constraints in the model. The matrix must be of size n_metabolites by n_reactions.\n\n\n\n\n\n","category":"method"},{"location":"reference/#IO-functions","page":"Reference","title":"IO functions","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [AbstractFBCModels]\nPages = [\"src/io.jl\"]","category":"page"},{"location":"reference/#AbstractFBCModels.eligible_model_types_for_filename-Tuple{String}","page":"Reference","title":"AbstractFBCModels.eligible_model_types_for_filename","text":"eligible_model_types_for_filename(path::String) -> Vector\n\n\nFind which of the known subtypes of AbstractFBCModel would typically be able to open the file at path, using information in filename_extensions.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.filename_extensions-Union{Tuple{Type{A}}, Tuple{A}} where A<:AbstractFBCModels.AbstractFBCModel","page":"Reference","title":"AbstractFBCModels.filename_extensions","text":"filename_extensions(\n    _::Type{A<:AbstractFBCModels.AbstractFBCModel}\n) -> Vector{String}\n\n\nA vector of filename extensions that are common for files that contain the given metabolic model type. This is used by load to guess the type of the model that should be loaded.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.guess_model_type_from_filename-Tuple{String}","page":"Reference","title":"AbstractFBCModels.guess_model_type_from_filename","text":"guess_model_type_from_filename(path::String) -> Any\n\n\nGuess which of the known subtypes of AbstractFBCModel would typically open the path (internally using eligible_model_types_for_filename for the purpose). Throws an error if the match is ambiguous or missing.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.load-Tuple{String}","page":"Reference","title":"AbstractFBCModels.load","text":"load(path::String) -> AbstractFBCModels.CanonicalModel.Model\n\n\nLoad a model from path. The type of the model is automatically guessed based on the filename extension. The guessing inspects all subtypes of AbstractFBCModel, thus always requires compilation – if possible, specify the proper type using the 2-parameter version of load to save time.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.load-Union{Tuple{A}, Tuple{Type{A}, String}} where A<:AbstractFBCModels.AbstractFBCModel","page":"Reference","title":"AbstractFBCModels.load","text":"load(\n    _::Type{A<:AbstractFBCModels.AbstractFBCModel},\n    path::String\n) -> AbstractFBCModels.CanonicalModel.Model\n\n\nLoad a model from path.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.pretty_print_kwdef-Union{Tuple{T}, Tuple{IO, T}} where T","page":"Reference","title":"AbstractFBCModels.pretty_print_kwdef","text":"pretty_print_kwdef(io::IO, x)\n\n\nHelper for nicely showing the contents of possibly complicated model structures.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.save-Tuple{AbstractFBCModels.AbstractFBCModel, String}","page":"Reference","title":"AbstractFBCModels.save","text":"save(a::AbstractFBCModels.AbstractFBCModel, path::String)\n\n\nSave a model to the given path.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Testing-of-model-implementations","page":"Reference","title":"Testing of model implementations","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [AbstractFBCModels]\nPages = [\"src/testing.jl\"]","category":"page"},{"location":"reference/#AbstractFBCModels.run_fbcmodel_file_tests-Union{Tuple{X}, Tuple{Type{X}, String}} where X<:AbstractFBCModels.AbstractFBCModel","page":"Reference","title":"AbstractFBCModels.run_fbcmodel_file_tests","text":"run_fbcmodel_file_tests(\n    ::Type{X<:AbstractFBCModels.AbstractFBCModel},\n    path::String;\n    name,\n    test_save\n) -> Union{Test.FallbackTestSet, Test.DefaultTestSet}\n\n\nTest if the given model type loads properly from a file.\n\nThe function uses the testing infrastructure from Test to report problems – it is supposed to be a part of larger test-sets, preferably in all model implementation packages.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.run_fbcmodel_type_tests-Union{Tuple{Type{X}}, Tuple{X}} where X<:AbstractFBCModels.AbstractFBCModel","page":"Reference","title":"AbstractFBCModels.run_fbcmodel_type_tests","text":"run_fbcmodel_type_tests(\n    _::Type{X<:AbstractFBCModels.AbstractFBCModel}\n) -> Union{Test.FallbackTestSet, Test.DefaultTestSet}\n\n\nTest if the given model type works right.\n\nThe function uses the testing infrastructure from Test to report problems – it is supposed to be a part of larger test-sets, preferably in all model implementation packages.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.@atest","page":"Reference","title":"AbstractFBCModels.@atest","text":"Internal helper macro for rendering easily interpretable test failures.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#Miscellaneous-utilities","page":"Reference","title":"Miscellaneous utilities","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [AbstractFBCModels]\nPages = [\"src/utils.jl\"]","category":"page"},{"location":"reference/#AbstractFBCModels.accessors-Tuple{}","page":"Reference","title":"AbstractFBCModels.accessors","text":"accessors() -> Vector{Method}\n\n\nProvide a methodswith-style listing of accessors that the model implementors should implement.\n\nFor typesystem reasons, the list will not contain methods for save and filename_extensions that dispatch on type objects. You should implement these as well.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.check_cached_file_hash-Tuple{Any, Any}","page":"Reference","title":"AbstractFBCModels.check_cached_file_hash","text":"check_cached_file_hash(path, expected_checksum)\n\n\nCheck if the file at path has the expected hash.\n\nAt this point, the hash is always SHA256.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.download_data_file-Tuple{Any, Any, Any}","page":"Reference","title":"AbstractFBCModels.download_data_file","text":"download_data_file(url, path, hash) -> Any\n\n\nDownload the file at url and save it at path, also check if this file is the expected file by calling check_cached_file_hash. If the file has already been downloaded and stored at path, then it is not downloaded again.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AbstractFBCModels.reaction_gene_products_available_from_dnf-Tuple{AbstractFBCModels.AbstractFBCModel, String, Function}","page":"Reference","title":"AbstractFBCModels.reaction_gene_products_available_from_dnf","text":"reaction_gene_products_available_from_dnf(\n    m::AbstractFBCModels.AbstractFBCModel,\n    reaction_id::String,\n    available::Function\n) -> Union{Nothing, Bool}\n\n\nUtility function to compute the value of reaction_gene_products_available for models that already implement reaction_gene_association_dnf.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Canonical-model-implementation","page":"Reference","title":"Canonical model implementation","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [AbstractFBCModels, AbstractFBCModels.CanonicalModel]\nPages = [\"src/canonical.jl\"]","category":"page"},{"location":"reference/#AbstractFBCModels.CanonicalModel.Gene","page":"Reference","title":"AbstractFBCModels.CanonicalModel.Gene","text":"mutable struct Gene\n\nA canonical Julia representation of a gene in the AbstractFBCModels interface.\n\nFields\n\nname::Union{Nothing, String}\nannotations::Dict{String, Vector{String}}\nnotes::Dict{String, Vector{String}}\n\n\n\n\n\n","category":"type"},{"location":"reference/#AbstractFBCModels.CanonicalModel.Metabolite","page":"Reference","title":"AbstractFBCModels.CanonicalModel.Metabolite","text":"mutable struct Metabolite\n\nA canonical Julia representation of a metabolite in the AbstractFBCModels interface.\n\nFields\n\nname::Union{Nothing, String}\ncompartment::Union{Nothing, String}\nformula::Union{Nothing, Dict{String, Int64}}\ncharge::Union{Nothing, Int64}\nbalance::Float64\nannotations::Dict{String, Vector{String}}\nnotes::Dict{String, Vector{String}}\n\n\n\n\n\n","category":"type"},{"location":"reference/#AbstractFBCModels.CanonicalModel.Model","page":"Reference","title":"AbstractFBCModels.CanonicalModel.Model","text":"struct Model <: AbstractFBCModels.AbstractFBCModel\n\nA canonical Julia representation of a metabolic model that sotres exactly the data represented by AbstractFBCModels accessors.\n\nThe implementation is useful for manipulating model data manually without writing new model types, or even for constructing models from base data in many simple cases.\n\nAdditionally, you can use the implementation of accessors for this model type in the source code of AbstractFBCModels as a starting point for creating an AbstractFBCModel interface for your own models.\n\nFields\n\nreactions::Dict{String, AbstractFBCModels.CanonicalModel.Reaction}\nmetabolites::Dict{String, AbstractFBCModels.CanonicalModel.Metabolite}\ngenes::Dict{String, AbstractFBCModels.CanonicalModel.Gene}\n\n\n\n\n\n","category":"type"},{"location":"reference/#AbstractFBCModels.CanonicalModel.Reaction","page":"Reference","title":"AbstractFBCModels.CanonicalModel.Reaction","text":"mutable struct Reaction\n\nA canonical Julia representation of a reaction in the AbstractFBCModels interface.\n\nFields\n\nname::Union{Nothing, String}\nlower_bound::Float64\nupper_bound::Float64\nstoichiometry::Dict{String, Float64}\nobjective_coefficient::Float64\ngene_association_dnf::Union{Nothing, Vector{Vector{String}}}\nannotations::Dict{String, Vector{String}}\nnotes::Dict{String, Vector{String}}\n\n\n\n\n\n","category":"type"},{"location":"#AbstractFBCModels.jl","page":"README","title":"AbstractFBCModels.jl","text":"","category":"section"},{"location":"","page":"README","title":"README","text":"Modules = [AbstractFBCModels]\nPages = [\"src/AbstractFBCModels.jl\"]","category":"page"},{"location":"#AbstractFBCModels.AbstractFBCModels","page":"README","title":"AbstractFBCModels.AbstractFBCModels","text":"Package AbstractFBCModels.jl defines a very general interface that allows access to data stored in flux-balanced constrained (FBC) models, which is a common way to represent metabolic models of organisms of various scales.\n\nThe interface enables 3 main goals:\n\nYou can load and save data from/to various types of FBC models, including the MatLab-based format (as used e.g. by CobraToolbox), JSON-based format (adopted by CobraPy), SBML, and others.\nYou can freely convert the model data among the formats using standard Julia convert().\nIf you created a new model exchange format, you can make it usable in all packages that already work with AbstractFBCModel interface just by implementing the API methods.\n\nThe package provides an additional \"canonical model\" format (in submodule CanonicalModel) that implements the bare minimum of features required to store all data representable via the general interface. You can use it as a base for implementing more complex model formats, or as a safe middle-point for model data conversion. See the examples in the documentation for details.\n\nThis package is lightweight and implements no other specific functionality. To load data from actual model formats, you will also need other packages that implement the functionality, such as SBMLFBCModels.jl.\n\n\n\n\n\n","category":"module"}]
}
